---
title: "Week2"
author: "Lisa Wahlen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Task 1: import Data

Create a new R- (or RMarkdown/Quarto-) file and begin with the following lines of code (adjust the path to your csv file accordingly).

### load the libraries

```{r}
library(readr) # to import tabular data (e.g. csv)
library(dplyr) # to manipulate (tabular) data
library(ggplot2) # to visualize data
library(sf) # to handle spatial vector data
library(terra) # To handle raster data
library(lubridate) # To handle dates and times
```

### Import the downloaded csv

```{r}
wildschwein_BE <- read_delim("data/wildschwein_BE_2056.csv", ",")

wildschwein_BE <- st_as_sf(wildschwein_BE, coords = c("E", "N"), crs = 2056, remove = FALSE)
```

Note:

-   that this dataset is already converted to EPSG 2056

-   the coordinates are stored in the columns (`E`/`N`)

-   setting `remove = FALSE` preserves the original (`E`/`N`) columns, which come in handy later on

## Task 2: Getting an overview

Calculate the time difference between subsequent rows as described in the demo. You can calculate the time difference using the function `difftime()` in combination with `lead()`.

-   the function `difftime()` has an option `units`. Set this to `secs` to get the time difference in seconds

-   use `as.integer()` to turn the output returned by `difftime()` into an integer.

-   store the output in a new column (e.g. `timelag`)

```{r}
wildschwein_diff <- wildschwein_BE |> 
  group_by(TierName) |> 
  mutate(time_diff = as.integer(difftime(DatetimeUTC, lag(DatetimeUTC, 1, default = NA, order_by = DatetimeUTC), units = "secs")))
```

Now inspect your data in more detail. Try to answer the following questions:

-   How many individuals were tracked?

```{r}
count <- wildschwein_BE |> 
  group_by(TierName) |> 
  summarise(total_count = n())
```

-   For how long were the individual tracked? Are there gaps?

```{r}
ggplot(wildschwein_BE, aes(DatetimeUTC, TierID)) + 
  geom_line()
```

-   Were all individuals tracked concurrently or sequentially?

-   What is the temporal sampling interval between the locations?

```{r}
ggplot(wildschwein_diff, aes(DatetimeUTC, time_diff, color=TierName)) +
  geom_line() +
  geom_point()
```

Here are some exemplary visualisation you could produce to answer these questions. Can you now answer the above questions?

After completing the task, commit your changes to git using a good commit message (e.g. `completed task 1`).

## **Task 3: Deriving movement parameters I: Speed**

In this task we will derive some additional movement parameters from our trajectories. So far our trajectories only consist of a list of time-stamped spatial locations. So let's calculate the animal's steplength based on the Euclidean distance between two subsequent locations.

You can calculate the Euclidean distance with the following formula:

$$distance = \sqrt{(E1-E2)^2+(N1-N2)^2}$$

-   `E1`, `N1` refers to the current location

-   `E2`, `N2` refers to the consecutive location

-   you can use `lead(E,1)` to address `E2`

-   store the output in a new column (e.g. `steplength`)

```{r}
wildschwein_temp <- wildschwein_diff |> 
  mutate(steplength = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2))
```

Now calculate the animals' speed between consecutive locations based on `steplength` and the `timelag` (from the last task). What speed unit do you get?

```{r}
wildschwein_temp <- wildschwein_temp |> 
  mutate(speed = steplength / time_diff)
```

The unit of the speed is meters per second.

After completing the task, commit your changes to git using a good commit message.

## **Task 4: Cross-scale movement analysis**

Laube and Purves ([2011](https://computationalmovementanalysis.github.io/FS23/90_references.html#ref-laube2011)) analyse animal movement across different scales (see below). In their paper, the authors suggest reducing the granularity of the data by subsetting the data to every n^th^ element. We will do the same on a dataset that includes 200 locations of a single wild boar with a constant sampling interval of 60 seconds.

Download this dataset here: [caro60.csv](https://moodle.zhaw.ch/pluginfile.php/1168373/mod_folder/content/0/caro60.csv?forcedownload=1). Import it just like you imported the other wild boar data and save it to a new variable named `caro` (note that the locations are stored in EPSG 2056).

```{r}
caro60 <- read_delim("data/caro60.csv", ",")
```

Now manually reduce the granularity of our sampling interval by selecting every 3^rd^, 6^th^ and 9^th^ position and save the output to `caro_3`, `caro_6`,`caro_9` accordingly.

Tip: There are many ways to go about this, we recommend using `seq()` where `from = 1`, `to =` the length of the dataset and `by = n` (i.e. `3`, `6` or `9`). This creates an integer vector that can either used in `dplyr::slice()` or in row subsetting (type `?slice()` or `?"[.data.frame"` to get help on either of these methods).

```{r}
caro_3 <- caro60[seq(1, nrow(caro60), 3), ]

caro_6 <- caro60[seq(1, nrow(caro60), 6), ]

caro_9 <- caro60[seq(1, nrow(caro60), 9), ]
```

You should now have 4 datasets with different number of rows.

Now calculate `timelag`, `steplength` and `speed` for these data sets, just as you did in the [last task](https://computationalmovementanalysis.github.io/FS23/Week2/W2_5_tasks_and_inputs.html#sec-w2-task3).

```{r}
caro_3 <- caro_3 |> 
  mutate(timelag = as.integer(difftime(
    DatetimeUTC, lag(DatetimeUTC, 1, default = NA, order_by = DatetimeUTC),
                                       units = "secs"))) |> 
  mutate(steplength = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2)) |>
  mutate(speed = steplength / timelag)
  
caro_6 <- caro_6 |> 
  mutate(timelag = as.integer(difftime(
    DatetimeUTC, lag(DatetimeUTC, 1, default = NA, order_by = DatetimeUTC),
                                       units = "secs"))) |> 
  mutate(steplength = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2)) |>
  mutate(speed = steplength / timelag)

caro_9 <- caro_9 |> 
  mutate(timelag = as.integer(difftime(
    DatetimeUTC, lag(DatetimeUTC, 1, default = NA, order_by = DatetimeUTC),
                                       units = "secs"))) |> 
  mutate(steplength = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2)) |>
  mutate(speed = steplength / timelag)

caro60 <- caro60 |> 
  mutate(timelag = as.integer(difftime(
    DatetimeUTC, lag(DatetimeUTC, 1, default = NA, order_by = DatetimeUTC),
                                       units = "secs"))) |> 
  mutate(steplength = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2)) |>
  mutate(speed = steplength / timelag)
```

To finish the task, compare the speeds visually in a line plot and also visualize the trajectories in a map (see examples below). Interpret the line plot, what do the different lines for the different temporal granularities tell you?

After completing the task, commit your changes to git using a good commit message.
